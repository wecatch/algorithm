<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 二叉查找树 · Hexo</title><meta name="description" content="二叉查找树 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/algorithm/favicon.ico"><link rel="stylesheet" href="/algorithm/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://wecatch.me/algorithm/atom.xml" title="Hexo"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Hexo</h2></a></div><a href="/algorithm/" target="_self" class="li component-nav-item"><p>首页</p></a><a href="/algorithm/categories/basic/" target="_self" class="li component-nav-item"><p>基础概念</p></a><a href="/algorithm/categories/advanced/" target="_self" class="li component-nav-item"><p>高级主题</p></a><a href="/algorithm/categories/practice/" target="_self" class="li component-nav-item"><p>最佳实践</p></a><a href="/algorithm/book" target="_self" class="li component-nav-item"><p>书籍推荐</p></a><a href="/algorithm/categories/projects/" target="_self" class="li component-nav-item"><p>开源项目</p></a></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">二叉查找树</h1><div class="post-info">Nov 28, 2017</div><div class="post-content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树首先是一颗二叉树，如果根节点的左子树不为空，则左子树所有节点的值都小于根节点，如果右子树不为空，则右子树所有值都大于根节点，二叉查找树的每一颗子树也是二叉查找树。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li>中序遍历二叉查找树得到的序列是由小到大</li>
<li>二叉查找树的查找时间为 O(logn)</li>
<li>节点结构包括 {lchild,rchild,key,value,N}</li>
</ul>
<p>二叉查找树的查找和插入几乎都是1.39logN</p>
<h1 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lchild = <span class="keyword">None</span></span><br><span class="line">        self.rchild = <span class="keyword">None</span></span><br><span class="line">        self.key = <span class="keyword">None</span></span><br><span class="line">        self.value = <span class="keyword">None</span></span><br><span class="line">        <span class="comment"># 节点计数器，以该节点为根的子树的节点总数，包含该节点</span></span><br><span class="line">        self.N = <span class="number">0</span> </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BST</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, node, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        查找</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, key, val)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        插入</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        最小</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">max</span><span class="params">(self, node)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        最大</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">floor</span><span class="params">(self, node, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        小于等于 key 的最大值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">ceil</span><span class="params">(self, node, key)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        大于等于 key 的最小值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>节点计数等式成立<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">size(x) = size(x.left) + size(x.right) + 1</span><br></pre></td></tr></table></figure></p>
<p>采用链式存储结构</p>
<h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>二叉查找树的递归查找很容易实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, node, key)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">if</span> key &lt; node.key:</span><br><span class="line">        <span class="keyword">return</span> self.get(node.left, key)</span><br><span class="line">    <span class="keyword">if</span> key &gt; node.key:</span><br><span class="line">        <span class="keyword">return</span> self.get(node.right, key)</span><br><span class="line">    <span class="keyword">return</span> node.value</span><br></pre></td></tr></table></figure>
<p>根据比较返回指定 key 在左子树或右子树的位置</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, node, key, val)</span>:</span></span><br><span class="line">    <span class="comment"># 如果树为空，生成新的节点</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> Node(key, val, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> key &lt; node.key:</span><br><span class="line">        node.left = self.put(node.left, key, val)</span><br><span class="line">    <span class="keyword">elif</span> key &gt; node.key:</span><br><span class="line">        node.right = self.put(node.right, key, val)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        node.val = val</span><br><span class="line">    node.n = self.size(node.left) + self.size(node.right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<p>插入操作中，如果树是空的，则返回包含有该健值对的新节点，如果小于当前节点，则插入到左子树，大于当前节点插入到右子树，在插入中每个递归的返回都是要重置路径上的每个父节点指向的子节点的连接，这是因为插入的新节点会导致已有的节点的左右连接发生变化。实际上在一个比较简单的二叉树中<strong>唯一更新的连接就是最底层指向新节点的连接</strong>，更上层连接的重置，可以通过比较来避免。</p>
<h2 id="最小键"><a href="#最小键" class="headerlink" title="最小键"></a>最小键</h2><p>如果根节点的左子树为空，最小键就是根节点，如果左子树非空，最小键就是左子树的最小键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    左子树中的最小的节点，也就是最左的节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> node.left:</span><br><span class="line">        <span class="keyword">return</span> self.min(node.left)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<h2 id="最大键"><a href="#最大键" class="headerlink" title="最大键"></a>最大键</h2><p>如果根节点的右子树为空，最大键就是根节点，如果右子树非空，最大键就是右子树的最大键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    右子树中的最大的节点，也就是最右的节点</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> node.right:</span><br><span class="line">        <span class="keyword">return</span> self.max(node.right)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<h2 id="向下取整-floor"><a href="#向下取整-floor" class="headerlink" title="向下取整 floor"></a>向下取整 floor</h2><p>想要查找 floor(G)，小于等于 G 的最大键，如果 G 小于二叉查找的根节点，floor(G) 一定在根节点的左子树中，如果 G 大于根节点，只有在根节点的右子树中存在小于 G 的节点时，floor(G) 才会出现在右子树中，否则根节点就是 floor(G)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">floor</span><span class="params">(self, node, key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    小于等于 key 的最大键, key 向下取整</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 当前节点大于 key</span></span><br><span class="line">    <span class="keyword">if</span> key &lt; node.key:</span><br><span class="line">        <span class="keyword">return</span> self.floor(node.left, key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点等于 key</span></span><br><span class="line">    <span class="keyword">if</span> key == node.key:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点小于 key 右子树中找大于 key 的键，因为右子树中的所有键小于当前节点</span></span><br><span class="line">    <span class="comment"># 右子树中存在小于 key 的键</span></span><br><span class="line">    t = self.floor(node.right, key)</span><br><span class="line">    <span class="comment"># 如果右子树不存在小于 key 的键，说明当前小于 key 的节点是那个 floor(key)，因为右子树的键都大于当前节点</span></span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<h2 id="向上取整-ceil"><a href="#向上取整-ceil" class="headerlink" title="向上取整 ceil"></a>向上取整 ceil</h2><p>想要查找 ceil(G)，大于等于 G 的最小健，如果 G 大于二叉查找的根节点，ceil(G) 根节点的右子树中，如果 G 小于根节点，只有在根节点的左子树中存在大于 G 的节点时，ceil(G) 才会出现在左子树中，否则根节点就是 ceil(G)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ceil</span><span class="params">(self, node, key)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    大于等于 key 的最小键, key 向上取整</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点小于 key</span></span><br><span class="line">    <span class="keyword">if</span> key &gt; node.key:</span><br><span class="line">        <span class="keyword">return</span> self.ceil(node.right, key)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点等于 key</span></span><br><span class="line">    <span class="keyword">if</span> key == node.key:</span><br><span class="line">        <span class="keyword">return</span> node</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 当前节点大于 key在左子树中找大于 key 的键，因为左子树中的所有键小于当前节点</span></span><br><span class="line">    <span class="comment"># 左子树中存在大于 key 的键</span></span><br><span class="line">    t = self.ceil(node.left, key)</span><br><span class="line">    <span class="comment"># 如果不存在，说明当前小于 key 的节点是那个 ceil(key)</span></span><br><span class="line">    <span class="keyword">if</span> t <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> t</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<h2 id="删除最小键"><a href="#删除最小键" class="headerlink" title="删除最小键"></a>删除最小键</h2><p>递归左子树直到左子树为空，然后删除该节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteMin</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    删除最小节点，不断递归左子树，直到左子树为空，则该节点是最小节点，返回该节点的右链接为上个节点的左子树</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">and</span> node.left <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> node.right</span><br><span class="line"></span><br><span class="line">    node.left = self.deleteMin(node.left)</span><br><span class="line">    node.N = self.size(node.left) + self.size(node.right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<h2 id="删除最大键"><a href="#删除最大键" class="headerlink" title="删除最大键"></a>删除最大键</h2><p>递归右子树直到右子树为空，然后删除该节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteMax</span><span class="params">(self, node)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    删除最大节点，不断递归右子树，直到右子树为空，则该节点是最大节点，返回该节点的左链接为上个节点的右子树</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">and</span> node.right <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> node.left</span><br><span class="line">    <span class="comment"># 向上不断更新右链接</span></span><br><span class="line">    node.right = self.deleteMax(node.right)</span><br><span class="line">    node.N = self.size(node.left) + self.size(node.right) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> node</span><br></pre></td></tr></table></figure>
<h2 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h2><p>如果删除的节点是最小或最大处理方式同上，如果删除节点是有两颗子树的节点需要特殊处理</p>
<p><img src="http://ozoxs1p4r.bkt.clouddn.com/WX20180113-134211@2x.jpg" alt=""></p>
<p>具体步骤如下<br>1.将被删除节点 node 保存为 t:<code>t = node</code><br>2.将被删除节点指向它的后继节点 node = min(t.right)<br>3.讲新节点 node 的右链接指向被删除节点删除最小节点之后的子树 <code>node.right = deleteMin(t.right)</code>，这样保证了其右子树都比 node 要大<br>4.将新节点 node 的左链接指向被删除节点的左链接，这样保证了左子树都比 node 要小</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/algorithm/posts/balance-tree/" class="prev">PREV</a><a href="/algorithm/posts/two-binary-tree-1/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://wecatch.me/algorithm">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p><p>本站文章遵循 <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">Creative Commons BY-NC-ND 4.0（自由转载-保持署名-非商用-禁止演绎）</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-79591400-1",'auto');ga('send','pageview');</script></body></html>
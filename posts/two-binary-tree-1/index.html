<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 二叉树 · Hexo</title><meta name="description" content="二叉树 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/algorithm/favicon.ico"><link rel="stylesheet" href="/algorithm/css/prontera.css"><link rel="search" type="application/opensearchdescription+xml" href="http://wecatch.me/algorithm/atom.xml" title="Hexo"></head><body><header class="feature-header"><nav class="component-nav"><ul><div class="logo-container"><a href="/"><h2 class="title">Hexo</h2></a></div><a href="/algorithm/" target="_self" class="li component-nav-item"><p>首页</p></a><a href="/algorithm/categories/basic/" target="_self" class="li component-nav-item"><p>基础概念</p></a><a href="/algorithm/categories/advanced/" target="_self" class="li component-nav-item"><p>高级主题</p></a><a href="/algorithm/categories/practice/" target="_self" class="li component-nav-item"><p>最佳实践</p></a><a href="/algorithm/book" target="_self" class="li component-nav-item"><p>书籍推荐</p></a><a href="/algorithm/categories/projects/" target="_self" class="li component-nav-item"><p>开源项目</p></a></ul></nav></header><main class="container"><div id="post-container"><div class="post"><article class="post-block"><h1 class="post-title">二叉树</h1><div class="post-info">Nov 28, 2017</div><div class="post-content"><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树是树的度为 2 的树，而且二叉树的每个节点子树是有顺序的，分别是左子树和右子树，二叉树是有序树</p>
<h1 id="二叉树的实现"><a href="#二叉树的实现" class="headerlink" title="二叉树的实现"></a>二叉树的实现</h1><p>二叉树的实现分为：顺序存储结构和链式存储结构。</p>
<h2 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h2><p>利用二叉树自身的一些性质来推断出其左右子树在顺序存储结构中的位置，由于顺序存储结构是以二叉树最大作为空间估算前提条件，对空间的利用不合理。</p>
<h2 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h2><p>在二叉树的链式存储结构中，每个节点都包含数据域、左右子孩子的链接。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = <span class="keyword">None</span></span><br><span class="line">        self.left = <span class="keyword">None</span></span><br><span class="line">        self.right = <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p>
<h1 id="二叉树的基本操作"><a href="#二叉树的基本操作" class="headerlink" title="二叉树的基本操作"></a>二叉树的基本操作</h1><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><p>二叉树的遍历是对二叉树中每个节点进行访问，完整遍历一棵树就是要遍历二叉树的根节点、左右子树。</p>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树</p>
<p><img src="http://ozoxs1p4r.bkt.clouddn.com/7178691-f61f5196e2fd7a77.png" alt="前序遍历"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    print(node.data)</span><br><span class="line">    traverse(node.left)</span><br><span class="line">    traverse(node.right)</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>若树为空，则空操作返回，否则从最左下结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树</p>
<p><img src="http://ozoxs1p4r.bkt.clouddn.com/7178691-02e28eaeedfcc187.png" alt="中序遍历"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    traverse(node.left)</span><br><span class="line">    print(node.data)</span><br><span class="line">    traverse(node.right)</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点</p>
<p><img src="http://ozoxs1p4r.bkt.clouddn.com/7178691-828924a25493a9c5.png" alt="后序遍历"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">traverse</span><span class="params">(node)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    traverse(node.left)</span><br><span class="line">    traverse(node.right)</span><br><span class="line">    print(node.data)</span><br></pre></td></tr></table></figure>
<h3 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h3><p>层序遍历又称广度优先搜索，按照从上到下、从左到右的顺序对节点按照节点所在的层进行遍历，借助队列实现<br>。</p>
<p><img src="http://ozoxs1p4r.bkt.clouddn.com/7178691-b40fef0f8efaa1cd.png" alt="层序遍历"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">layerorder</span><span class="params">(node)</span>:</span></span><br><span class="line">    queue = list()</span><br><span class="line">    path = list()</span><br><span class="line">    queue.append(node)</span><br><span class="line">    <span class="keyword">while</span> len(queue):</span><br><span class="line">        current = queue.pop(<span class="number">0</span>)</span><br><span class="line">        path.append(current.val)</span><br><span class="line">        <span class="keyword">if</span> current.left:</span><br><span class="line">            queue.append(current.left)</span><br><span class="line">        <span class="keyword">if</span> current.right:</span><br><span class="line">            queue.append(current.right)</span><br></pre></td></tr></table></figure>
<h1 id="二叉树的实际应用和操作"><a href="#二叉树的实际应用和操作" class="headerlink" title="二叉树的实际应用和操作"></a>二叉树的实际应用和操作</h1><h2 id="问题【1】求一个节点的父节点"><a href="#问题【1】求一个节点的父节点" class="headerlink" title="问题【1】求一个节点的父节点"></a>问题【1】求一个节点的父节点</h2><p>二叉树是单向的层次结构，无法直接由子节点获取父节点，但是我们可以根据层序遍历的思想获得父节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_parent</span><span class="params">(root, node)</span>:</span></span><br><span class="line">    queue = []</span><br><span class="line">    queue.append(root)</span><br><span class="line">    <span class="keyword">while</span> len(queue):</span><br><span class="line">        current_node = queue.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> current_node.left:</span><br><span class="line">            queue.append(current_node.left)</span><br><span class="line">            <span class="keyword">if</span> current_node.left == node:</span><br><span class="line">                <span class="keyword">return</span> current_node</span><br><span class="line">        <span class="keyword">if</span> current_node.right:</span><br><span class="line">            queue.append(current_node.right)</span><br><span class="line">            <span class="keyword">if</span> current_node.right == node:</span><br><span class="line">                <span class="keyword">return</span> current_node</span><br></pre></td></tr></table></figure>
<h2 id="问题【2】求一个节点的兄弟节点"><a href="#问题【2】求一个节点的兄弟节点" class="headerlink" title="问题【2】求一个节点的兄弟节点"></a>问题【2】求一个节点的兄弟节点</h2><p>由于二叉树的单向的层次结构，获取兄弟节点可以借助先获取父节点然后再通过父节点获取兄弟节点</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">find_parent(root, node).left</span><br><span class="line">find_parent(root, node).right</span><br></pre></td></tr></table></figure>
<h2 id="问题【3】求一个二叉树的高度"><a href="#问题【3】求一个二叉树的高度" class="headerlink" title="问题【3】求一个二叉树的高度"></a>问题【3】求一个二叉树的高度</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法 1"></a>方法 1</h3><p>递归的去遍历所有节点求树高度，最后就演化成只要求根节点子树的高度对比就行，非常容易实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_tree_depth1</span><span class="params">(node, depth=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    递归的写法</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> node <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        <span class="keyword">return</span> depth</span><br><span class="line">    depth += <span class="number">1</span></span><br><span class="line">    left_depth = get_tree_depth1(node.left, depth)</span><br><span class="line">    right_depth = get_tree_depth1(node.right, depth)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max(left_depth, right_depth)</span><br></pre></td></tr></table></figure>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法 2"></a>方法 2</h3><p>如果树的高度非常高，会导致递归的层次非常深，可以改成循环.</p>
<p>二叉树的高度也就是二叉树的深度，等于二叉树的叶子节点的最大深度，这里我们需要对二叉树进行深度遍历来获得二叉树的节点深度和最大深度，鉴于此我们在遍历过程中需要进行回退，因为事先我们是不知道哪一条遍历的路径是最长的，所以需要借助栈这种可以回退的结构。</p>
<h2 id="问题【4】"><a href="#问题【4】" class="headerlink" title="问题【4】"></a>问题【4】</h2><p>根据二叉树的前序遍历和中序遍历重建二叉树</p>
</div></article></div></div></main><footer class="footer-container"><div class="paginator"><a href="/algorithm/posts/two-binary-search-tree-1/" class="prev">PREV</a><a href="/algorithm/posts/link-list-2/" class="next">NEXT</a></div><div class="copyright"><p>© 2017 - 2018 <a href="http://wecatch.me/algorithm">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/AngryPowman/hexo-theme-prontera" target="_blank">hexo-theme-prontera</a>.</p><p>本站文章遵循 <a href="http://creativecommons.org/licenses/by-nc-nd/4.0/deed.zh">Creative Commons BY-NC-ND 4.0（自由转载-保持署名-非商用-禁止演绎）</a></p></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-79591400-1",'auto');ga('send','pageview');</script></body></html>